PATH="/Library/Frameworks/Python.framework/Versions/2.7/bin:/Applications/Postgres.app/Contents/Versions/9.5/bin:${PATH}"
# Remove duplicates from PATH
PATH=$(echo "$PATH" | awk -v RS=':' -v ORS=":" '!a[$1]++' | sed 's/:$//' | tr -d '\n')
export PATH
export EDITOR="/usr/local/bin/mate -w"
export SCREENSHOTS='/Users/gavin/Screenshots/'
export CODESNIP='/Users/gavin/Code Snippets/'

alias cdev="cd $DEVPATH"
alias cdmic="cd $DEVPATH/micromasters"
alias cdm=cdmic
alias cdedx="cd $DEVPATH/edx_devstack"
export SANDBOXPATH="$DEVPATH/sandbox"
alias cdsandbox="cd $SANDBOXPATH"

alias fixenter="stty sane"
makegif() {
  palette="/tmp/palette.png"
  filters="fps=10,scale=600:-1:flags=bicubic"
  if (( $# < 2 )); then
    input="$1.mov"
	output="$1.gif"
  else
    input="$1"
	output="$2"
  fi
  if [ ! -f "$input" ] ; then
    input_temp="/Users/gavin/Screenshots/$input"
	output_temp="/Users/gavin/Screenshots/$output"
	if [ -f "$input_temp" ]; then
	  input="$input_temp"
	  output="$output_temp"
	fi
  fi
  ffmpeg -v warning -i "$input" -vf "$filters,palettegen" -y $palette
  ffmpeg -v warning -i "$input" -i $palette -lavfi "$filters [x]; [x][1:v] paletteuse" -y "$output"
}
snippet() {
  new_file_path="$CODESNIP"
  if [ ! -z "$2" ]; then
    new_file_path="$new_file_path/$1"
  fi
  cp "$1" "$new_file_path"
}
urlencode() {
  python -c "import urllib, sys; print urllib.quote(sys.argv[1])" $1
}
alias vhalt='vagrant halt'

export VIRTUALENVWRAP_SH_PATH="/Library/Frameworks/Python.framework/Versions/2.7/bin/virtualenvwrapper.sh"
export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$DEVPATH
source "$VIRTUALENVWRAP_SH_PATH"
venv() {
  cwd=$(pwdtail)
  if [ -d "$WORKON_HOME/$cwd" ]; then
    workon "$cwd"
  else
    echo "'$cwd' is not an existing virtualenv"
  fi
}
alias venvoff='deactivate'
venvcreate() {
  cwd=$(echo "${PWD##*/}")
  if [ -d "$WORKON_HOME/$cwd" ]; then
    echo "'$cwd' virtualenv already exists"
  else
    mkvirtualenv "$cwd" $@
    workon "$cwd"
  fi
}
venvdelete() {
  venvoff
  cwd=$(echo "${PWD##*/}")
  if [ -d "$WORKON_HOME/$cwd" ]; then
    rm -rf "$WORKON_HOME/$cwd"
  fi
}
venvcurrent() {
  echo "$VIRTUAL_ENV"
}

alias pynbhere='jupyter notebook'
alias pynb="pynbhere --notebook-dir=$SANDBOXPATH"

# Git magic
export GITHUB_API_URL="https://api.github.com"
export GIT_AUTHOR_LABEL_NAME="Waiting on Author"
export GIT_REVIEW_LABEL_NAME="Needs Review"
gsetapivalues() {
  curbranch=$(gcurbranch)
  remote_tail=$(git remote show origin -n | grep 'Push' | grep -Eo '(\w+)/(\w+)\.git$')
  github_owner=$(echo "$remote_tail" | grep -Eo '^\w+')
  github_repo=$(echo "$remote_tail" | perl -nle 'print $& if m{(?<=/)\w+}')
}
gh_api_call() {
  if (( $# < 1 )); then
    echo "Need >= 1 param"
    return
  else
    api_url_stub="$1"; shift
  fi
  full_url="$GITHUB_API_URL/$api_url_stub"
  # echo "$full_url"
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$full_url" $@
}
gh_repos_api_call() {
  if (( $# < 1 )); then
    echo "Need >= 1 param"
    return
  else
    api_url_stub="$1"; shift
  fi
  gsetapivalues
  gh_api_call "repos/$github_owner/$github_repo/$api_url_stub" $@
}
gh_prs_api_call() {
  gsetapivalues
  api_url_stub="search/issues?q=repo:$github_owner/$github_repo+state:open+is:pr"
  if [ ! -z "$1" ]; then
    api_url_stub="$api_url_stub+$1"
  fi
  gh_api_call "$api_url_stub"
}
gh_pr_api_call() {
  gsetapivalues
  api_url_stub="pulls"
  #/repos/:owner/:repo/pulls/
}
gh_issue_api_call() {
  gsetapivalues
  if (( $# < 1 )); then
    echo "Need issue #"; return
  else
    issue_number="$1"; shift
	api_url_stub="$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$issue_number"
    if (( $# > 0 )); then
	  if [ '?' != $(echo "$1" | head -c 1) ]; then
	    api_url_stub="$api_url_stub/"
	  fi
	  api_url_stub="$api_url_stub$1"
	fi
  fi
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$api_url_stub"
  
}
gmergetomaster() {
  curbranch=$(gcurbranch)
  git checkout master && git pull && git merge "$curbranch"
  git push
}
gcurbranchprinfo() {
  gsetapivalues
  local params=''
  if [ ! -z $1 ]; then
    params="&$1"
  fi
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls?head=$github_owner:$curbranch$params"
}
getissuefrombranch() {
  gcurbranch | grep -Eo '^[0-9]+'
}
gprissue() {
  if [ -z "$1" ]; then
    echo "Need PR issue # as param"
    return
  fi
  gh_repos_api_call "pulls/$1" | jq '.["body"]' | grep -Eo "[closes|Closes|fixes|Fixes]\s+\#\d+" | grep -Eo "\d+$"
}
gopenpr() {
  gcurbranchprinfo | jq -r '.[0] | .["_links"]["html"]["href"]' | xargs open
}
gopenissue() {
  if [ -z "$1" ]; then
    # attempt to match numbers at the beginning of the branch name, which should indicate issue #
    issue=$(getissuefrombranch)
  else
    issue="$1"
  fi
  if [ -z "$issue" ]; then
    echo "No issue # specified"
  else
    gsetapivalues
    curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$issue" | jq -r '.["html_url"]' | xargs open
  fi
}
gopenprissue() {
  if [ -z "$1" ]; then
    pr_issue_number=$(gcurbranchprinfo | jq '.[0]["number"]')
  else
    pr_issue_number=$1
  fi
  gopenissue $(gprissue "$pr_issue_number")
}
gchprbranch() {
  if [ -z "$1" ]; then
    echo "Need PR issue # as param"
    return
  else
    pr_issue="$1"
  fi
  gsetapivalues
  branch_name=$(curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls/$pr_issue" | jq -r '.["head"]["ref"]')
  git fetch && git checkout "$branch_name"
}
alias gchpr=gchprbranch
gprlabelset() {
  gsetapivalues
  if [ -z "$1" ]; then
    echo "Need label name as param"; return
  else
    label_to_add="$1"
  fi
  if [ -z "$2" ]; then
    issue_url=$(curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls?head=$github_owner:$curbranch" | jq -r '.[0]["issue_url"]')
  else
    issue_url="$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$2"
  fi
  issue_labels_url="$issue_url/labels"
  curl -s -X PUT -u "$GIT_USERNAME:$GIT_TOKEN" "$issue_labels_url" -H "Content-Type: application/json" -d '["'"$label_to_add"'"]'
}
gprlabelreview() {
  gprlabelset "$GIT_REVIEW_LABEL_NAME" $1
}
alias gprlabelneeds=gprlabelreview
gprlabelwaiting() {
  gprlabelset "$GIT_AUTHOR_LABEL_NAME" $1
}
gmyissues() {
  gsetapivalues && gh_api_call "search/issues?q=assignee:$GIT_USERNAME+repo:$github_owner/$github_repo+state:open" | jq '.["items"][] | {number: .["number"], title: .["title"], url: .["html_url"]} + if has("pull_request") then {is: "PULL REQUEST"} else {} end  + if (.["labels"] | any(.["name"] == "epic")) then {is: "EPIC"} else {} end'
}
gmyprsassigned() {
  gh_prs_api_call "assignee:$GIT_USERNAME" | jq '.["items"][] | {number: .["number"], title: .["title"], author: .["user"]["login"], label: [.["labels"][] | .["name"]] | join(", ")}'
}
gmyprscreated() {
  gh_prs_api_call "author:$GIT_USERNAME" | jq '.["items"][] | {number: .["number"], title: .["title"], label: [.["labels"][] | .["name"]] | join(", ")}'
}
alias gmyprs="echo 'ASSIGNED' && gmyprsassigned && echo 'CREATED' && gmyprscreated"
gsquash() {
  curbranch=$(gcurbranch)
  local branch_parent_commit=$(git merge-base $curbranch master)
  if [ -z "$curbranch" ]; then
    echo "No current branch obtained. No squashy."
  elif [[ "$curbranch" == "master" ]]; then
    echo "You are currently on master. No squashy."
  elif [ -z "$branch_parent_commit" ]; then
    echo "No branch parent commit found. No squashy."
  else
    commitmsg=''
    if (( $# < 1 )); then
	  curbranchprtitle=$(gcurbranchprinfo | jq -r 'if . | length == 0 then "" else .[0]["title"] end')
	  if [ -z "$curbranchprtitle" ]; then
	    # Get the commit hash for the first commit after the merge-base
	    first_branch_commit=$(git log --format=%H | tr '\n' ',' | grep -Eo "\w+,$branch_parent_commit" | grep -Eo "^[^,]+")
		# Get the commit message
		proposed_title=$(git show "$first_branch_commit" --format="%s" --no-patch)
	  else
	    proposed_title="$curbranchprtitle"
	  fi
      read -q "REPLY?No message specified. Use the following? [$proposed_title]: "
	  echo
	  case "$REPLY" in
        y|Y ) commitmsg="$proposed_title";;
        * ) echo "Need to specify a commit message. No squashy." && return;;
      esac
	else
	  commitmsg="$(echo $@)"
	fi
    git reset --soft "$branch_parent_commit"
    git commit -am "$commitmsg"
    #git push -f
  fi
}
gtagrelease() {
  if [ -z "$1" ]; then
    echo "Need tag as param"
    return
  else
    # coerce to semantic version - eliminates 'v', etc.
	tag=$(echo "$1" | grep -Eo '\d+\.\d+\.\d+')
	if [ -z "$tag" ]; then
	  echo "Tag ($1) is not a valid semantic version"
	  return
	fi
  fi
  git tag -a -m "Release $tag" "v$tag"
  # git push --follow-tags
}
alias grebmaster='git fetch && git rebase origin/master'
alias grebabort='git rebase --abort'
alias grebcontinue='git rebase --continue'
gsnipchanges() {
  local filename=''
  local filepath=''
  local fileext="$1"
  if [ ! -z $2 ]; then
    filename="$2"
  else
    local cleancurbranch=$(gcurbranch | sed 's/\//\-/g')
    filename="$cleancurbranch"
  fi
  if [ -f "$CODESNIP/$filename.$fileext" ]; then
    filename="$filename-$(epoch)"
  fi
  filepath="/tmp/$filename.$fileext"
  git diff > "$filepath" && snippet "$filepath" && rm -f "$filepath"
}
gpatchsnip() { gsnipchanges 'patch' $@; }
gdiffsnip() { gsnipchanges 'diff' $@; }


# Docker functions and aliases
dockenv() { eval "$(docker-machine env $1)" }
alias docksshc='docker-machine ssh'
alias docksshm='docker-compose run web bash'
alias dockstop='docker-machine stop'
alias dockrestart='docker-machine restart'
alias dockbuild='docker-compose build'

# Project-specific commands
# MM
export MM_MACHINE_NAME='mm'
alias mmenv="dockenv $MM_MACHINE_NAME"
alias mmstartmachine="docker-machine start $MM_MACHINE_NAME"
alias mmsetup='mmstartmachine; mmenv'
alias mmrestart='dockrestart mm'
mm() {
  if [ $(pwd) != "$DEVPATH/micromasters" ]; then
    echo "Changing directory to $DEVPATH/micromasters"
	cdm
  fi
  if [ $(docker-machine status $MM_MACHINE_NAME) != "Running" ]; then
    mmstartmachine
  fi
  if [ "$DOCKER_MACHINE_NAME" != "$MM_MACHINE_NAME" ]; then
    echo "Setting docker env variables"
	mmenv
  fi
  if [[ $(venvcurrent) != *$(pwdtail)* ]]; then
    echo "Setting virtualenv"
  	venv
  fi
}
alias mmstart='mm && docker-compose up'
alias mmstartdb='mm && docker-compose up db'
alias mmstartdbelastic='mm && docker-compose up db elastic'
alias mmstartweb='mm && docker-compose run --service-ports web'
mmmanage() {
	mm && docker-compose run web ./manage.py $@
}
alias mmmakemigration='mmmanage makemigrations'
mmshowmigrations() { mmmanage showmigrations $1; }
mmmigrate() { mmmanage migrate $@; }
alias mmip='docker-machine ip '"$MM_MACHINE_NAME"
alias mmstartserver='mmenv && docker-compose run --service-ports web ./manage.py runserver 0.0.0.0:8079'
alias mmwebpack='./webpack_dev_server.sh'
alias mmshell='docker-compose run web ./manage.py shell'
alias mmindex='docker-compose run web ./manage.py recreate_index'
mmsearchindex() {
  if [ ! -z $1 ]; then
    esquery="?q=$1"
  else
    esquery=""
  fi
  docker-compose run web curl "http://elastic:9200/micromasters/_search?$esquery" | jq '.'
}
mmfullstaticbuild() {
  local debug=$(cat ./docker-compose.yml | grep -Eo "DEBUG: 'True'")
  if [ ! -z "$debug" ]; then
    git apply $CODESNIP/patches/docker_debug_false.patch
  fi
  node node_modules/webpack/bin/webpack.js --config webpack.config.prod.js --bail &&
    docker-compose run web ./manage.py collectstatic --no-input &&
    echo "\nRESTART THE MM SERVER"
}
mmcleanstaticbuild() {
  local notdebug=$(cat ./docker-compose.yml | grep -Eo "DEBUG: 'False'")
  if [ ! -z "$notdebug" ]; then
    git checkout -- ./docker-compose.yml
  fi
  docker-compose run web bash -c "rm -rf ./staticfiles"
}
mmdb() {
  mmenv && psql -h $(mmip) -p $(mmdbport) -U postgres
}
mmdbrun() {
  mmenv && psql -h $(mmip) -p $(mmdbport) -U postgres -c $@
}
mmdbnotfilledout() {
  mmdbrun "update profiles_profile set filled_out = 'f' where edx_name = 'staff';"
}
mmdbfilledout() {
  mmdbrun "update profiles_profile set filled_out = 't' where edx_name = 'staff';"
}
mmtestcfgminimal() {
  /bin/cp -f pytest_minimal.ini pytest.ini
}
mmtestcfgrevert() {
  git checkout origin/master pytest.ini
}
alias mmtest='./test_suite.sh'
alias mmlintjs='docker-compose run watch npm run-script lint'
alias mmtestjs='docker-compose run watch npm test'
mmtestjsdirect() {
  if [ ! -z "$1" ]; then
    testfile="$1"; shift
  fi
  node ./node_modules/mocha/bin/_mocha --compilers js:babel-register static/js/global_init.js ${testfile:-'static/**/*/*_test.js'} $@
}
mmtestjsgrep() {
  mmtestjsdirect "$1" --grep "$2"
}
alias mmtestfull='docker-compose run watch npm test && docker-compose run watch npm run-script lint'
alias mmtestsuite='. ./test_suite.sh'
alias mmflow='docker-compose run watch npm run-script flow'
alias mmlintpy='docker-compose run web pylint'
alias mmtestpy='docker-compose run web tox'
mmtestpymin() {
  local keepmin=''
  if [ ! -z "$1" ] && [ "$1" = '--keepmin' ]; then;
    keepmin="true"; shift
  fi
  mmtestcfgminimal && docker-compose run web tox $@;
  if [ -z "$keepmin" ]; then
  	mmtestcfgrevert
  fi
}
alias mmtestpyminkeep='mmtestpymin --keepmin'
alias mmtoxenv='. .tox/py35/bin/activate'
alias mmdjangodebug='cp $CODESNIP/settingsfiles/.env_django_debug ~/dev/micromasters/.env'
alias mmdjangowarning='cp $CODESNIP/settingsfiles/.env_django_warning ~/dev/micromasters/.env'
alias mmgetdbport="docker-compose ps | grep '_db' | grep -Eo '[^ ]+\s+$' | grep -Eo ':(\d+)' | cut -c 2-"
mmdbport() {
	export MM_DB_PORT=$(mmgetdbport)
    if [ -z "$1" ] || [ "$1" != '-s' ]; then
	  echo "$MM_DB_PORT"
	fi
}
alias mmnb='mm && mmdbport -s && jupyter notebook micromasters.ipynb --log-level=ERROR' # --notebook-dir=".ipynb"


# Random startup
alias edxstart='cd ~/dev/edx_devstack && vup && vssh'
alias edxstartfresh='cd ~/dev/edx_devstack && vhalt && vup && vssh'

# Pythonz setup
[[ -s $HOME/.pythonz/etc/bashrc ]] && source $HOME/.pythonz/etc/bashrc
