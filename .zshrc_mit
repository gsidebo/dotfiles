PATH="/usr/local/bin:/Library/Frameworks/Python.framework/Versions/2.7/bin:/Applications/Postgres.app/Contents/Versions/9.5/bin:${PATH}"
# Remove duplicates from PATH
PATH=$(echo "$PATH" | awk -v RS=':' -v ORS=":" '!a[$1]++' | sed 's/:$//' | tr -d '\n')
export PATH

export EDITOR="/usr/local/bin/mate -w"
export SCREENSHOTS='/Users/gavin/Screenshots'
export CODESNIP='/Users/gavin/Code Snippets'

alias edit='charm'
alias f='open -a Finder ./' # Opens current directory in MacOS Finder

export MM_PATH="$DEVPATH/micromasters"
export BOOTCAMP_PATH="$DEVPATH/bootcamp-ecommerce"
export SANDBOX_PATH="$DEVPATH/sandbox"
export OPDISC_PATH="$DEVPATH/open-discussions"
export OVS_PATH="$DEVPATH/odl-video-service"
export EDX_FICUS_PATH="$DEVPATH/edx_devstack_ficus"
export EDX_GINKGO_PATH="$DEVPATH/edx_devstack_ginkgo"
export RDEVPATH="$HOME/devreddit"
export REDDIT_CONF_PATH="$RDEVPATH/reddit-config"
export REDDIT_PATH="$RDEVPATH/reddit"
export XQUEUE_DOCKER_PATH="$DEVPATH/mitodlfork/xqueue-docker/"
export XQUEUE_VAGRANT_PATH="$DEVPATH/mitodlfork/xqueue-vagrant/"
export XQUEUE_EDX_VAGRANT_PATH="$DEVPATH/xqueue-vagrant/"
export XQUEUE_WATCHER_CFG_PATH="$DEVPATH/mitodlfork/xqueue-watcher-docker/"
export XQUEUE_WATCHER_SRC_PATH="$DEVPATH/mitodlfork/xqueue-watcher-docker/xqueue-watcher/"
export SALTSTACK_SANDBOX_PATH="$DEVPATH/salt-essentials-utils"
alias cdmic="cd $MM_PATH"
alias cdm=cdmic
alias cdboot="cd $BOOTCAMP_PATH"
alias cdsandbox="cd $SANDBOX_PATH"
alias cdovs="cd $OVS_PATH"
alias cdedxf="cd $EDX_FICUS_PATH"
alias cdedxg="cd $EDX_GINKGO_PATH"
alias cdedx=cdedxg
alias cdrdev="cd $RDEVPATH"
alias cdopdisc="cd $OPDISC_PATH"
alias cdredcon="cd $REDDIT_CONF_PATH"
alias cdxqueue="cd $XQUEUE_DOCKER_PATH"
alias cdxqueuevagrant="cd $XQUEUE_VAGRANT_PATH"
alias cdxqueueedxvagrant="cd $XQUEUE_EDX_VAGRANT_PATH"
alias cdxqueuewatch="cd $XQUEUE_WATCHER_CFG_PATH"
alias cdxqueuewatchsrc="cd $XQUEUE_WATCHER_SRC_PATH"
alias cdsaltsandbox="cd $SALTSTACK_SANDBOX_PATH"

# Virtualenv settings
export VIRTUALENV_PYTHON=/usr/local/bin/python3
export VIRTUALENVWRAPPER_PYTHON=$VIRTUALENV_PYTHON
export VIRTUALENVWRAP_SH_PATH="/usr/local/bin/virtualenvwrapper.sh"
export WORKON_HOME=$HOME/.virtualenvs
export PROJECT_HOME=$DEVPATH
source "$VIRTUALENVWRAP_SH_PATH"

alias fixenter="stty sane"
makegif() {
  palette="/tmp/palette.png"
  filters="fps=10,scale=600:-1:flags=bicubic"
  if (( $# < 2 )); then
    input="$1.mov"
	output="$1.gif"
  else
    input="$1"
	output="$2"
  fi
  if [ ! -f "$input" ] ; then
    input_temp="/Users/gavin/Screenshots/$input"
	output_temp="/Users/gavin/Screenshots/$output"
	if [ -f "$input_temp" ]; then
	  input="$input_temp"
	  output="$output_temp"
	fi
  fi
  ffmpeg -v warning -i "$input" -vf "$filters,palettegen" -y $palette
  ffmpeg -v warning -i "$input" -i $palette -lavfi "$filters [x]; [x][1:v] paletteuse" -y "$output"
}
snippet() {
  new_file_path="$CODESNIP"
  if [ ! -z "$2" ]; then
    new_file_path="$new_file_path/$1"
  fi
  cp "$1" "$new_file_path"
}
alias pastejson='pbpaste | jq .'
alias pastejsoncopy='pbpaste | jq . | pbcopy'

alias pynbhere='jupyter notebook'
alias pynb="pynbhere --notebook-dir=$SANDBOX_PATH"

# Simple Git shortcuts
alias gchrelease='git checkout release'
alias gchrc='git checkout release-candidate'
alias gchginkgo='git checkout mitx/ginkgo'

# Git magic
export GITHUB_URL="https://github.com"
export GITHUB_API_URL="https://api.github.com"
export GIT_AUTHOR_LABEL_NAME="Waiting on Author"
export GIT_REVIEW_LABEL_NAME="Needs Review"
gsetremote() {
  local branch=''
  if [ ! -z $1 ]; then
    branch="$1"
  else
    branch=$(gcurbranch)
  fi
  local git_remote=$(git config "branch.$branch.remote")
  if [ -z "$git_remote" ]; then
    git_remote=$(git config "branch.master.remote")
    if [ -z "$git_remote" ]; then
      echo "Couldn't determine a remote for current branch or master"
      exit 1
    else
      echo "Branch $branch has no remote. Defaulting to master remote ($remote)"
    fi
  fi
  echo "$git_remote"
}
gsetapivalues() {
  git_remote=$(gsetremote $1)
  remote_tail=$(git remote -v | grep 'push' | grep "$git_remote" | perl -nle '/.*github\.com[\/|:]([^\/]+\/.*)\.git/ && print "$1";')
  github_owner=$(echo "$remote_tail" | grep -Eo '^\w+')
  github_repo=$(echo "$remote_tail" | perl -nle '/\/(.*)$/ && print "$1";')
  if [ -z "$github_owner" ] || [ -z "$github_repo" ]; then
    echo "Could not properly set github_owner or github_repo."
  fi
}
gh_api_call() {
  if (( $# < 1 )); then
    echo "Need >= 1 param"
    return
  else
    api_url_stub="$1"; shift
  fi
  full_url="$GITHUB_API_URL/$api_url_stub"
  # echo "$full_url"
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$full_url" $@
}
gh_repos_api_call() {
  if (( $# < 1 )); then
    echo "Need >= 1 param"
    return
  else
    api_url_stub="$1"; shift
  fi
  gsetapivalues
  gh_api_call "repos/$github_owner/$github_repo/$api_url_stub" $@
}
gh_prs_api_call() {
  gsetapivalues
  api_url_stub="search/issues?q=repo:$github_owner/$github_repo+state:open+is:pr"
  if [ ! -z "$1" ]; then
    api_url_stub="$api_url_stub+$1"
  fi
  gh_api_call "$api_url_stub"
}
gh_pr_api_call() {
  gsetapivalues
  api_url_stub="pulls"
  #/repos/:owner/:repo/pulls/
}
gh_issue_api_call() {
  gsetapivalues
  if (( $# < 1 )); then
    echo "Need issue #"; return
  else
    issue_number="$1"; shift
	api_url_stub="$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$issue_number"
    if (( $# > 0 )); then
	  if [ '?' != $(echo "$1" | head -c 1) ]; then
	    api_url_stub="$api_url_stub/"
	  fi
	  api_url_stub="$api_url_stub$1"
	fi
  fi
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$api_url_stub"
  
}
gh_site_url_base() {
  gsetapivalues
  echo "$GITHUB_URL/$github_owner/$github_repo"
}
gmergetomaster() {
  git checkout master && git pull && git merge $(gcurbranch)
  git push
}
gcurbranchprinfo() {
  gsetapivalues
  local params=''
  if [ ! -z $1 ]; then
    params="&$1"
  fi
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls?head=$github_owner:$(gcurbranch)$params"
}
getissuefrombranch() {
  gcurbranch | grep -Eo '^[0-9]+'
}
gprissue() {
  if [ -z "$1" ]; then
    echo "Need PR issue # as param"
    return
  fi
  gh_repos_api_call "pulls/$1" | jq '.["body"]' | grep -Eo "[closes|Closes|fixes|Fixes]\s+\#\d+" | grep -Eo "\d+$"
}
gopenpr() {
  gcurbranchprinfo | jq -r '.[0] | .["_links"]["html"]["href"]' | xargs open
}
gopenissue() {
  if [ -z "$1" ]; then
    # attempt to match numbers at the beginning of the branch name, which should indicate issue #
    issue=$(getissuefrombranch)
  else
    issue="$1"
  fi
  if [ -z "$issue" ]; then
    echo "No issue # specified"
  else
    gsetapivalues
    curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$issue" | jq -r '.["html_url"]' | xargs open
  fi
}
gopenprissue() {
  if [ -z "$1" ]; then
    pr_issue_number=$(gcurbranchprinfo | jq '.[0]["number"]')
  else
    pr_issue_number=$1
  fi
  gopenissue $(gprissue "$pr_issue_number")
}
gopencommit() {
  local urlbase=''
  if [ -z "$1" ]; then
    echo "Need commit SHA as param"
    return
  fi
  urlbase=$(gh_site_url_base)
  open "$urlbase/commit/$1"
}
gprbranchname() {
  if [ -z "$1" ]; then
    echo "Need PR issue # as param"
    return
  fi
  curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls/$1" | jq -r '.["head"]["ref"]'
}
gchprbranch() {
  if [ -z "$1" ]; then
    echo "Need PR issue # as param"
    return
  fi
  gsetapivalues
  local branch_name=$(gprbranchname $1)
  git fetch && git checkout $branch_name
}
alias gchpr=gchprbranch
gprlabelset() {
  gsetapivalues
  if [ -z "$1" ]; then
    echo "Need label name as param"; return
  else
    label_to_add="$1"
  fi
  if [ -z "$2" ]; then
    issue_url=$(curl -s -u "$GIT_USERNAME:$GIT_TOKEN" "$GITHUB_API_URL/repos/$github_owner/$github_repo/pulls?head=$github_owner:$(gcurbranch)" | jq -r '.[0]["issue_url"]')
  else
    issue_url="$GITHUB_API_URL/repos/$github_owner/$github_repo/issues/$2"
  fi
  issue_labels_url="$issue_url/labels"
  curl -s -X PUT -u "$GIT_USERNAME:$GIT_TOKEN" "$issue_labels_url" -H "Content-Type: application/json" -d '["'"$label_to_add"'"]'
}
gprlabelreview() {
  gprlabelset "$GIT_REVIEW_LABEL_NAME" $1
}
alias gprlabelneeds=gprlabelreview
gprlabelwaiting() {
  gprlabelset "$GIT_AUTHOR_LABEL_NAME" $1
}
gmyissues() {
  gsetapivalues && gh_api_call "search/issues?q=assignee:$GIT_USERNAME+repo:$github_owner/$github_repo+state:open" | jq '.["items"][] | {number: .["number"], title: .["title"], url: .["html_url"]} + if has("pull_request") then {is: "PULL REQUEST"} else {} end  + if (.["labels"] | any(.["name"] == "epic")) then {is: "EPIC"} else {} end'
}
gmyprsassigned() {
  gh_prs_api_call "assignee:$GIT_USERNAME" | jq '.["items"][] | {number: .["number"], title: .["title"], author: .["user"]["login"], label: [.["labels"][] | .["name"]] | join(", ")}'
}
gmyprscreated() {
  gh_prs_api_call "author:$GIT_USERNAME" | jq '.["items"][] | {number: .["number"], title: .["title"], label: [.["labels"][] | .["name"]] | join(", ")}'
}
alias gmyprs="echo 'ASSIGNED' && gmyprsassigned && echo 'CREATED' && gmyprscreated"
gsquash() {
  local curbranch=$(gcurbranch)
  local branch_parent_commit=$(git merge-base $curbranch master)
  if [ -z "$curbranch" ]; then
    echo "No current branch obtained. No squashy."
  elif [[ "$curbranch" == "master" ]]; then
    echo "You are currently on master. No squashy."
  elif [ -z "$branch_parent_commit" ]; then
    echo "No branch parent commit found. No squashy."
  else
    commitmsg=''
    if (( $# < 1 )); then
	    curbranchprtitle=$(gcurbranchprinfo | jq -r 'if . | length == 0 then "" else .[0]["title"] end')
	    if [ -z "$curbranchprtitle" ]; then
	      # Get the commit hash for the first commit after the merge-base
	      first_branch_commit=$(git log --format=%H | tr '\n' ',' | grep -Eo "\w+,$branch_parent_commit" | grep -Eo "^[^,]+")
		  # Get the commit message
	  	proposed_title=$(git show "$first_branch_commit" --format="%s" --no-patch)
	    else
	      proposed_title="$curbranchprtitle"
	    fi
      read -q "REPLY?No message specified. Use the following? [$proposed_title]: "
	    echo
	    case "$REPLY" in
        y|Y ) commitmsg="$proposed_title";;
        * ) echo "Need to specify a commit message. No squashy." && return;;
      esac
	  else
	    commitmsg="$(echo $@)"
	  fi
    git reset --soft "$branch_parent_commit"
    git commit -am "$commitmsg"
    #git push -fz
  fi
}
gtagrelease() {
  if [ -z "$1" ]; then
    echo "Need tag as param"
    return
  else
    # coerce to semantic version - eliminates 'v', etc.
	tag=$(echo "$1" | grep -Eo '\d+\.\d+\.\d+')
	if [ -z "$tag" ]; then
	  echo "Tag ($1) is not a valid semantic version"
	  return
	fi
  fi
  git tag -a -m "Release $tag" "v$tag"
  # git push --follow-tags
}
alias grebmaster='git fetch && git rebase origin/master'
alias grebabort='git rebase --abort'
alias grebcontinue='git rebase --continue'
alias grebskip='git rebase --skip'
gsnipchanges() {
  local filename=''
  local filepath=''
  local fileext="$1"
  if [ ! -z $2 ]; then
    filename="$2"
  else
    local cleancurbranch=$(gcurbranch | sed 's/\//\-/g')
    filename="$cleancurbranch"
  fi
  if [ -f "$CODESNIP/$filename.$fileext" ]; then
    filename="$filename-$(epoch)"
  fi
  filepath="/tmp/$filename.$fileext"$
  git diff > "$filepath" && snippet "$filepath" && rm -f "$filepath"
}
gpatchsnip() { gsnipchanges 'patch' $@; }
gdiffsnip() { gsnipchanges 'diff' $@; }


# Docker functions and aliases
dockenv() { eval "$(docker-machine env $1)" }
alias docksshc='docker-machine ssh'
alias docksshm='docker-compose run web bash'
alias dockstop='docker-machine stop'
alias dockrestart='docker-machine restart'
alias dockstart='docker-machine start'
alias dockbuild='docker-compose build'
alias dockpause='docker-compose pause'
alias dockunpause='docker-compose unpause'
alias dockgetdbport="docker-compose ps | grep '_db' | grep -Eo '[^ ]+\s+$' | grep -Eo ':(\d+)' | cut -c 2-"
alias dockup='docker-compose up'
alias dockregen='docker-machine regenerate-certs'
dockdbport() {
	export DOCK_DB_PORT=$(dockgetdbport)
    if [ -z "$1" ] || [ "$1" != '-s' ]; then
	  echo "$DOCK_DB_PORT"
	fi
}
docksetup() {
  local devpath=$1
  local machinename=$2
  if [[ "$devpath" == "." ]]; then
    devpath=$(pwd)
  fi
  if [ $(pwd) != "$devpath" ]; then
    echo "Changing directory to $devpath"
	  cd $devpath
  fi
  if [ $(docker-machine status $machinename) != "Running" ]; then
    docker-machine start $machinename
  fi
  if [ "$DOCKER_MACHINE_NAME" != "$machinename" ]; then
    echo "Setting docker env variables"
	  dockenv $machinename
  fi
  if [[ $(venvcurrent) != *$(pwdtail)* ]]; then
    echo "Setting virtualenv"
  	venv
  fi
}
alias vboxprocesses="ps xao pid,command | grep 'VBox' | grep -v 'grep'"
startnb() {
  local machinename=$1
  local notebookname
  local notebookpath
  if [ -z $machinename ]; then
    echo "Need to specify the machine name"
    return
  elif [ -z $2 ]; then
    notebookname=$machinename
  else
    notebookname=$2
  fi
  notebookpath="./$notebookname.ipynb"
  if [ ! -f "$notebookpath" ]; then
    echo "Notebook does not exist ($notebookpath)"
    return
  fi
  docksetup . $machinename && dockdbport -s && jupyter notebook $notebookname.ipynb --log-level=ERROR
}
dockip() {
  local machinename
  if [ ! -z $1 ]; then
    machinename="$1"
  else
    machinename="$DOCKER_MACHINE_NAME"
  fi
  docker-machine ip $machinename; 
}
dockdbport() { docker-compose ps | grep '_db' | perl -nle '/[0-9\.]*:(\d+)/ && print "$1";' }
docknginxport() {
  # hacky af, bruh
  cat docker-compose.yml | grep 'nginx:' -A 15 | grep 'ports:' -A 1 | head -2 | tail -1 | perl -nle '/(\d+)\"/ && print "$1";'
}
openrunning() {
  local runningmachine
  if [ ! -z $1 ]; then
    runningmachine=$1
  else
    runningmachine=$DOCKER_MACHINE_NAME
  fi
  local machineip=$(docker-machine ip $runningmachine)
  local webappport=$(docknginxport)
  if [[ -z $machineip || -z $runningmachine || -z $webappport ]]; then
    echo "Error - Missing one of the following: running machine ($runningmachine), IP ($machineip), port ($webappport)"
    return
  fi
  open "http://$machineip:$webappport"
}

# Node stuff
alias webpack="./webpack_dev_server.sh"
alias webpackinstall="./webpack_dev_server.sh --install"
alias webpackinstallsass="npm rebuild node-sass --force && webpackinstall"

##############################################
### General and specific codebase commands ###
##############################################

# General
alias lintjs='docker-compose run watch npm run-script lint'
alias lintsass='docker-compose run watch npm run-script scss_lint'
alias lint='lintjs && lintsass'
alias lintpy='docker-compose run web pylint'
alias testpy='docker-compose run web tox'
alias testcfgminimal='/bin/cp -f pytest_minimal.ini pytest.ini'
alias testcfgrevert='git checkout origin/master pytest.ini'
testpymin() {
  local keepmin=''
  if [ ! -z "$1" ] && [ "$1" = '--keepmin' ]; then;
    keepmin="true"; shift
  fi
  testcfgminimal && docker-compose run web tox $@;
  if [ -z "$keepmin" ]; then
  	testcfgrevert
  fi
}
alias testpyminkeep='testpymin --keepmin'
alias testjs="./scripts/test/js_test.sh"
alias testjsroot="./js_test.sh"
alias flowjs='npm run-script flow'
dmanage() { docker-compose run web ./manage.py $@; }
alias dshell='dmanage shell'
alias makemigration='dmanage makemigrations'
migrate() { dmanage migrate $@; }
dbconnect() { psql -h $(dockip) -p $(dockdbport) -U postgres }
dbrun() {
  local runcmd
  local db
  if [ ! -z $2 ]; then
    runcmd="$2"
	  db="$1"
  else
    runcmd="$1"
	  db="postgres"
  fi
  local dbport=$(dockdbport)
  if [ -z $dbport ]; then
    echo "No DB port detected. Is the 'db' service running?"
  else
    psql -h $(dockip) -p $(dockdbport) -U postgres --dbname=$db -c $runcmd
  fi
}

# EDX
alias edxfstart='cd $EDX_FICUS_PATH && vup && vssh'
alias edxfstartfresh='cd $EDX_FICUS_PATH && vhalt && vup && vssh'
alias edxgstart='cd $EDX_GINKGO_PATH && vup && vssh'
alias edxgstartfresh='cd $EDX_GINKGO_PATH && vhalt && vup && vssh'

# MICROMASTERS
export MM_MACHINE_NAME='mm'
alias mmenv="dockenv $MM_MACHINE_NAME"
alias mmstartmachine="docker-machine start $MM_MACHINE_NAME"
alias mmsetup='mmstartmachine; mmenv'
alias mmrestart='dockrestart mm'
alias mm="docksetup $MM_PATH $MM_MACHINE_NAME"
alias mmstart='mm && docker-compose up'
alias mmstartdb='mm && docker-compose up db'
alias mmstartdbelastic='mm && docker-compose up db elastic'
alias mmstartnonweb='mm && docker-compose up db elastic celery redis sftp'
alias mmstartweb='mm && docker-compose run --service-ports web'
alias mmstartwebnginx='mm && docker-compose up nginx web'
alias mmwebpdb='docker-compose run --service-ports web ./manage.py runserver 0.0.0.0:8077'
alias mmweb=mmstartweb
alias mmwebnginx=mmstartwebnginx
alias mmdbelastic=mmstartdbelastic
alias mmnonweb=mmstartnonweb
mmmanage() {
	mm && docker-compose run web ./manage.py $@
}
alias mmmakemigration='mmmanage makemigrations'
mmshowmigrations() { mmmanage showmigrations $1; }
mmmigrate() { mmmanage migrate $@; }
alias mmip='docker-machine ip '"$MM_MACHINE_NAME"
alias mmstartserver='mmenv && docker-compose run --service-ports web ./manage.py runserver 0.0.0.0:8079'
alias mmwebpack='mm && webpack'
alias mmwebpackinstall='mm && webpackinstall'
alias mmshell='mm && docker-compose run web ./manage.py shell'
alias mmindex='mm && docker-compose run web ./manage.py recreate_index'
alias mmseed='mm && docker-compose run web ./manage.py seed_db --staff-user=staff'
alias mmunseed='mm && docker-compose run web ./manage.py unseed_db'
mmsearchindex() {
  if [ ! -z $1 ]; then
    esquery="?q=$1"
  else
    esquery=""
  fi
  docker-compose run web curl "http://elastic:9200/micromasters/_search?$esquery" | jq '.'
}
mmfullstaticbuild() {
  local debug=$(cat ./docker-compose.yml | grep -Eo "DEBUG: 'True'")
  if [ ! -z "$debug" ]; then
    git apply $CODESNIP/patches/docker_debug_false.patch
  fi
  node node_modules/webpack/bin/webpack.js --config webpack.config.prod.js --bail &&
    docker-compose run web ./manage.py collectstatic --no-input &&
    echo "\nRESTART THE MM SERVER"
}
mmcleanstaticbuild() {
  local notdebug=$(cat ./docker-compose.yml | grep -Eo "DEBUG: 'False'")
  if [ ! -z "$notdebug" ]; then
    git checkout -- ./docker-compose.yml
  fi
  docker-compose run web bash -c "rm -rf ./staticfiles"
}
mmdb() { 
  mmenv && dbconnect
}
mmdbrun() {
  mmenv && dbrun $@
}
mmdbnotfilledout() {
  mmdbrun "update profiles_profile set filled_out = 'f' where edx_name = 'staff';"
}
mmdbfilledout() {
  mmdbrun "update profiles_profile set filled_out = 't' where edx_name = 'staff';"
}
alias mmtest='./test_suite.sh'
alias mmtestfull='docker-compose run watch npm test && docker-compose run watch npm run-script lint'
alias mmtestsuite='. ./test_suite.sh'
alias mmtoxenv='. .tox/py35/bin/activate'
alias mmdjangodebug='cp $CODESNIP/settingsfiles/.env_django_debug ~/dev/micromasters/.env'
alias mmdjangowarning='cp $CODESNIP/settingsfiles/.env_django_warning ~/dev/micromasters/.env'
alias mmnb='mm && dockdbport -s && jupyter notebook micromasters.ipynb --log-level=ERROR' # --notebook-dir=".ipynb"
mmsetloglevel() {
  sed -i -e "s/MICROMASTERS_LOG_LEVEL=$1/MICROMASTERS_LOG_LEVEL=$2/g" .env
  sed -i -e "s/DJANGO_LOG_LEVEL=$1/DJANGO_LOG_LEVEL=$2/g" .env
}
alias mmsetdebug="mmsetloglevel WARNING DEBUG"
alias mmsetwarning="mmsetloglevel DEBUG WARNING"

# BOOTCAMP
export BOOTCAMP_MACHINE_NAME='bootcamp'
alias bootenv="dockenv $BOOTCAMP_MACHINE_NAME"
alias bootstartmachine="docker-machine start $BOOTCAMP_MACHINE_NAME"
alias bootsetup='bootstartmachine; bootenv'
alias bootrestart="dockrestart $BOOTCAMP_MACHINE_NAME"
alias bootcamp="docksetup $BOOTCAMP_PATH $BOOTCAMP_MACHINE_NAME"
alias bootstart='bootcamp && docker-compose up'
alias bootstartdec='bootcamp && docker-compose up db elastic celery'
alias bcamp=bootcamp
alias bstart=bootstart
bootmanage() {
	bootcamp && docker-compose run web ./manage.py $@
}
alias bootshell='bootmanage shell'
alias bootnb="startnb $BOOTCAMP_MACHINE_NAME"
alias boottestjs='./scripts/test/js_test.sh'
bootdb() { 
  bootenv && dbconnect
}
bootdbrun() {
  bootenv && dbrun $@
}

# REDDIT/REDDIT-CONFIG
alias redditrebuild="pushd $REDDIT_CONF_PATH && vagrant reload && vagrant provision && popd"
alias redditrestart="vagrant ssh -c 'sudo reddit-restart'"
alias redditlasterror="vagrant ssh -c \"sudo tac /var/log/upstart/reddit-paster.log | grep -m 1 'Debug at:' | grep -Eo 'http[^\s]*'\""
alias redditstatus='curl -s --head "http://reddit.local/" --connect-timeout 3 | head -n 1'
alias redditrunning='redditstatus | grep -o "200 OK"'

# OPEN-DISCUSSIONS
export OPDISC_MACHINE_NAME='opdisc'
alias opdisc="docksetup $OPDISC_PATH $OPDISC_MACHINE_NAME"
alias odstart="docker-machine start $OPDISC_MACHINE_NAME"
odsmartstart() {
  local rstatus=$(redditstatus)
  if [ -z $rstatus ]; then
    echo "Reddit not running locally. Restarting VM..."
    redditrebuild
  else
    local running=$(echo $rstatus | grep -o "200 OK")
    if [ -z $running ]; then
      echo "Reddit server status: [$rstatus]. Restarting server..."
      redditrestart
    fi
  fi
  docker-machine start $OPDISC_MACHINE_NAME
  docker-compose up
}

# ODL-VIDEO-SERVICE
export OVS_MACHINE_NAME='ovs'
alias ovs="docksetup $OVS_PATH $OVS_MACHINE_NAME"
alias ovsstart="docker-machine start $OVS_MACHINE_NAME"
alias ovsnb="startnb $OVS_MACHINE_NAME"

# SALTSTACK LOCAL STUFF
export SALTSTACK_SANDBOX_VM_PATH="$SALTSTACK_SANDBOX_PATH/virtual-machines"
alias cdsaltsandvagrant="cd $SALTSTACK_SANDBOX_VM_PATH"
alias saltsandup="cdsaltsandvagrant && vagrant up"

# Pythonz setup
[[ -s $HOME/.pythonz/etc/bashrc ]] && source $HOME/.pythonz/etc/bashrc
